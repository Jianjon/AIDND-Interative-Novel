import { GoogleGenerativeAI } from "@google/generative-ai";
import { formatModuleContext } from "../data/modules_data.js";

/**
 * CartographerAgent: The World Keeper
 * Responsible for location tracking and quest journaling.
 * Inputs: Narrative Text + Current Location
 * Outputs: JSON Updates (Location, Journal Entry)
 */
export class CartographerAgent {
    constructor(apiKey) {
        this.genAI = new GoogleGenerativeAI(apiKey);
        this.model = this.genAI.getGenerativeModel({
            model: "gemini-2.5-flash-preview-09-2025",
            generationConfig: { responseMimeType: "application/json" }
        });
    }

    /**
     * Updates world state based on narrative events.
     * @param {Object} context
     * @param {string} context.narrative - The text generated by StoryAgent.
     * @param {Array} context.currentLocation - Current path (["City", "District", "Shop"]).
     * @param {number} context.turnCount - Current game turn.
     * @returns {Promise<Object>} JSON object with location and journal_entry.
     */
    async updateJournal(context) {
        const { narrative, currentLocation, turnCount, signals, moduleId = null, currentAct = 1 } = context;

        // Get module plot context for location guidance
        const plotContext = moduleId ? formatModuleContext(moduleId, currentAct) : '';

        const systemPrompt = `
        You are the **Cartographer** (World Logic Engine).
        **CRITICAL: ALL OUTPUT MUST BE IN TRADITIONAL CHINESE (繁體中文). NO ENGLISH.**
        Your role is to maintain world continuity, track location changes, and summarize key events.

        === CORE PRINCIPLES ===
        1. **Cross-Agent Awareness**
           - **GM Signals**: ${signals ? JSON.stringify(signals) : "None"}
           - Integrate signals from StoryAgent, GMAgent, CharacterManager.
           - If narrative implies movement (e.g., "descending stairs"), infer a sub-area update.
           - If GM signals "Combat", record the encounter start/end.

        2. **Autonomous Completion**
           - If information is missing, reasonably infer and fill the gap.
           - If a new location appears in narrative, treat it as valid.
           - Do NOT wait for user instructions to update the journal.

        3. **World Consistency**
           - Ensure the world map remains coherent.
           - If something contradicts previous logs, reconcile it gracefully.

        [CURRENT LOCATION]
        ${JSON.stringify(currentLocation)}
        
        [NARRATIVE INPUT]
        "${narrative}"

${plotContext ? `[MODULE PLOT CONTEXT]\n${plotContext}\n` : ''}
        [TASKS]
        1. **Location Tracking**: Decide whether the party moved, transitioned zones, or entered a sub-area.
        2. **Journal Entry Creation**: Produce a NEW log entry with 3 layers:
           - **Public**: Concise summary for the UI.
           - **Logic**: Updates for world state (e.g., "NPC X Hostile", "Door Locked").
           - **Hooks**: Potential future plot threads.

        [OUTPUT SCHEMA]
        {
            "location": ["Phandalin", "Town Square"],
            "journal_entry": {
                "public": "Turn ${turnCount}: The party arrived in Phandalin...",
                "logic": ["Met Gundren", "Gundren is anxious"],
                "hooks": ["Strange map mentioned"]
            }
        }
        `;

        try {
            const result = await this.model.generateContent(systemPrompt);
            const response = result.response;
            const text = response.text();
            const usage = response.usageMetadata;
            return { data: JSON.parse(text), usage };
        } catch (error) {
            console.error("CartographerAgent Error:", error);
            // Fallback: No change
            return {
                data: {
                    location: currentLocation,
                    journal_entry: null
                },
                usage: null
            };
        }
    }
}
